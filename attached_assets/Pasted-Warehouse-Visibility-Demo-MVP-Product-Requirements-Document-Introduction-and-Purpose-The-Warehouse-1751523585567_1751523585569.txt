Warehouse-Visibility Demo MVP – Product Requirements Document
Introduction and Purpose
The Warehouse-Visibility Demo MVP is a front-end only prototype of the “Operational & Inventory Visibility” module for a WMS (Warehouse Management System). Its purpose is to demonstrate key features and UI/UX of the visibility module using 100% mock data, while appearing and behaving like a fully functional system. The demo will showcase real-time operational insights through interactive 2D heatmaps and live tracking of warehouse resources, empowering stakeholders to visualize how the finished product could improve decision-making and efficiency. This prototype will be used in stakeholder presentations to gather feedback and buy-in, so it must be polished and intuitive despite having no real backend. Goals and Objectives:
Provide real-time operational transparency on a warehouse floor map (via simulated data).
Visualize high-activity zones and bottlenecks using heatmaps for various metrics (Volume, Frequency, etc.).
Highlight inventory issues like misplacements and near-expiry stock to illustrate potential error reduction.
Simulate live resource tracking (e.g. forklifts) to demonstrate improved resource utilization and route optimization.
Ensure the UI/UX is intuitive and presentation-ready, with responsive design and clear visual cues, so stakeholders can easily grasp the functionality.
(Note: All data in this demo is fake but deterministic, generated by seeded algorithms to appear realistic. There are no real-time feeds or database integrations in this MVP.)
Scope of the MVP Demo
In-Scope (MVP Features)
Interactive 2D Warehouse Map: A static 2D grid layout of the warehouse rendered on canvas (using Konva in React) with support for smooth pan and zoom at 30 FPS. This map depicts aisles, racks, and bin locations in correct scale.
Six Heatmap Overlays: Visualization layers for six metrics – Volume, Frequency, Occupancy, Misplacement, Expiry, and Exceptions – which can be toggled on/off. Each heatmap layer highlights the warehouse bins or zones according to the metric’s values (e.g. high volume areas in warmer colors). Switching between these overlays should feel instantaneous (under 500 ms).
Live Resource Icons: Simulation of moving resource icons (e.g. forklift icons) on the map. ~3 forklifts are shown moving along predefined paths, with their positions updating every 1 second via a mock WebSocket. Icons move smoothly between updates to appear like real real-time tracking.
Resource Trace Overlay: Clicking on a resource icon will display its last 5 minutes of movement history as a path on the map. Path segments are color-coded (e.g. green when the forklift was carrying a load, red when empty) to convey loaded vs. unloaded travel. This helps illustrate how the system can distinguish productive vs. unladen travel. The path updates continuously with each new position update.
Time-Range Controls: A time-range slider (covering 15 minutes up to 24 hours) allows the user to adjust the data interval for heatmaps. For example, sliding to “last 2 hours” will regenerate the heatmap layers to reflect aggregated values in that timeframe. The slider interaction is debounced by ~300 ms to avoid performance issues (the heatmap re-renders only after the user stops adjusting for a moment).
Layer Toggle Controls: “Eye” icon toggles are provided in the UI to show or hide each overlay layer (each of the 6 heatmaps, as well as the live resources layer). Users can, for instance, turn off the resource icons for clarity or compare two heatmap layers by toggling them. The toggle state for each layer persists via the URL hash, so the view can be restored or shared with the same configuration.
SKU Search and Highlight: A search bar allows users to enter a SKU identifier (full or partial). On search, any bin locations containing that SKU will be highlighted (flashed) on the map. This simulates inventory lookup – for example, if SKU “ABC123” is stored in certain bins, those bins blink or outline to draw attention. The highlight clears when the search is cleared or on pressing Escape.
Export Current View: A one-click Export button triggers a download of the current canvas view as a PNG image. This allows capturing the heatmap or tracking view shown on screen. The exported image file is named with the layer and timestamp (e.g. “heatmap-volume-20250703.png”). This feature is implemented with a client-side library (such as html-to-image) since there is no backend.
Out of Scope (Future Enhancements)
(The following capabilities are beyond the MVP scope and may be considered in later phases):
Real Data Integration: No real-time location system (RTLS) feeds or WMS database connections are included. All data is simulated; live integration with actual warehouse data will come later.
Automated Floor-Plan Imports: Importing actual facility floor plans (e.g. CAD drawings or SVGs) and 3D visualizations of the warehouse are not included in this demo. The MVP uses a hard-coded layout grid.
Advanced Analytics & Optimization: Features like 3D views, predictive analytics for routing or optimization, automatic task generation, or detailed PDF/CSV reporting are out of scope. The demo focuses only on visualization and basic interactivity, not on back-end analytics or optimization.
Production-Grade Hardening: Authentication, role-based access control, data encryption, multi-user support, and scalable infrastructure are not addressed in this prototype. The demo runs locally or on a simple static host purely for showcasing the UI.
Warehouse Layout Model (Synthetic Data Layout)
The demo uses a synthetic warehouse layout to mirror a realistic storage setup while allowing quick lookups for rendering. The topology is a small warehouse section with 4 aisles (A1–A4) of pallet racks, each rack being two-pallets deep (meaning each rack location has a front and a back position). There are 3 vertical levels of storage (L1 = floor level, L2, L3). Each aisle side has 60 bin positions per level.
Total Visible Bin Faces: 4 aisles × 60 bins × 3 levels = 720 bin faces (i.e. distinct front-facing storage locations visible on the map).
Total Pallet Positions: 720 faces × 2 (depth) = 1,440 pallet positions in the simulated model.
Each storage cell (pallet position) is identified by a Cell ID using the format: {Aisle}-{Bin}-{Level}-{Depth}. For example, “A2-B37-L2-D1” refers to the location in Aisle 2, Bin 37, Level 2, Depth 1 (front pallet slot). The naming conventions are:
Aisle: A1, A2, A3, A4 (corridors or rack rows).
Bin: B01, B02, ... B60 (column index along the aisle).
Level: L1, L2, L3 (vertical level of the rack, L1 is ground).
Depth: D1 or D2 (D1 = front slot, D2 = back slot in a two-deep rack).
A JSON configuration file (e.g. layout.json) enumerates every cell with its coordinates on the canvas grid and dimensions, for rapid lookup during rendering. For instance, a snippet of layout.json might look like:
json
Copy
Edit
[
  { "cellId": "A1-B01-L1-D1", "x": 10, "y": 20, "w": 20, "h": 15 },
  { "cellId": "A1-B01-L1-D2", "x": 10, "y": 40, "w": 20, "h": 15 },
  ... 
]
Each entry gives the position (x, y) and size (w, h) of a cell on the canvas, so the grid can be drawn accurately. The origin (0,0) corresponds to a fixed corner of the warehouse layout.
Functional Requirements (MVP Features)
Below are the functional requirements for the demo. Each requirement is labeled (FR-D#) and includes key acceptance criteria:
FR-D01 – Warehouse Grid Rendering: The system shall render the warehouse layout grid based on the provided layout.json file. Users can pan (click-drag) and zoom (pinch or scroll) the view smoothly. Acceptance: The canvas must maintain ~30 frames per second performance during interactions (smooth navigation) and correctly scale all elements during zoom.
FR-D02 – Heatmap Overlays: The system shall overlay a heatmap layer on the grid given an array of values ([{cellId, metric}, …]). It should automatically scale the intensity from 0 to 1 (or use a color gradient) based on min/max values. Six metric types are supported: Volume, Frequency, Occupancy, Misplacement, Expiry, and Exceptions. Users can switch the active heatmap type via the UI, and the view updates within 500 ms of selection. Acceptance: Toggling between metric layers should be almost instant (<0.5s) and the color scaling should adjust dynamically for each metric’s range.
FR-D03 – Live Resource Animation: The system shall connect to a mock WebSocket (simulated via Socket.io) that pushes frequent resource updates. Every 1 second, each moving resource (e.g. forklift) sends a new { id, x, y, loaded } position payload. The front-end animates the resource icon’s movement from its last position to the new position smoothly (interpolating between updates). Acceptance: Resource icon positions update with sub-second latency – within 1s of the data push – and move along a smooth path (no jerky jumps). The icons should visibly travel along their routes on the map.
FR-D04 – Resource Path Trace on Click: When a user clicks a resource icon, the system shall draw that resource’s recent path (last 5 minutes of movement) on the map. The path is visualized as a polyline or trail overlay. Segments of the path are colored green when the resource was carrying a load, and red when it was empty (no load), to provide context on productive versus empty travel. The path should continuously update as new location data comes in (sliding window of 5 min). Acceptance: Toggling the path on icon click works reliably – the path appears immediately and updates in real-time. The color-coding accurately reflects the loaded flag from the data (e.g., if loaded: true, that segment is green). The path overlay should be distinguishable but not obstruct other information (e.g. slightly translucent lines).
FR-D05 – Time-Range Slider Filtering: The UI shall provide a time-range slider allowing the user to select a timeframe between 15 minutes and 24 hours. Adjusting this slider filters or rebuilds the heatmap data to that range (simulating “historical” heatmap views). The system only updates the heatmap when the user stops moving the slider (debounce ~300 ms) to avoid excessive re-rendering. Acceptance: Changing the time range causes the heatmap to refresh with new values corresponding to that range, within 0.5s. The slider’s current value (e.g. “6h”) is clearly indicated, and rapid adjustments don’t produce lag or freeze the UI.
FR-D06 – Layer Toggle Controls: The interface shall include layer toggle buttons (eye icons) for each overlay layer (each metric heatmap, and the moving resources). Users can individually hide or show any layer. For example, one could hide the “Occupancy” heatmap layer to reduce clutter, or hide the moving resources if only the heatmap is of interest. The state of these toggles is reflected in the URL hash (allowing the configuration to be shareable or restorable on page refresh). Acceptance: Toggling any layer immediately hides/shows the corresponding visuals. Hidden layers do not appear in the export or interfere with visible layers. The URL hash updates on toggle and if copied, yields the same layer visibility state when reloaded.
FR-D07 – SKU Search Highlight: The system shall allow users to search for a SKU (stock-keeping unit) by ID or partial ID. Upon searching, all bin locations containing that SKU (as per the dummy inventory data) will be highlighted on the map. The highlight can be a flashing border or an icon marker on those bins. The search is case-insensitive and could provide auto-suggestions (if feasible, using the fake data set). Pressing ESC or clearing the search input removes the highlights. Acceptance: A search query (e.g. “SKU123”) results in immediate visual feedback – all relevant bins light up or flash within <1 second. If no locations contain the SKU, a “No results” indicator is shown. The highlight is clearly visible (e.g. a pulsating outline or glow) but does not permanently alter the map. Escaping or deleting the query cleanly removes all highlights.
FR-D08 – Export View to Image: The interface shall provide an Export button (e.g. a camera or download icon) which allows the user to download the current map view as a PNG image. The export should capture exactly what is visible (respecting current zoom, panning, and visible layers). The resulting image file is automatically named in the format heatmap-{layer}-{timestamp}.png (for heatmap views) or map-export-{timestamp}.png if multiple layers are shown. Acceptance: Clicking the export triggers a download without needing page reload. The image matches the on-screen content at the moment of capture (verified by comparing colors and positions), and text/graphics are not cut off. The export should complete within a second or two for a typical view. (Underlying implementation can use a library like html-to-image or canvas toDataURL().)
Data Simulation Rules (Dummy Data Generation)
All data displayed in this demo is simulated via deterministic algorithms to ensure the visuals look realistic and consistent on each run. The generation is seeded, so the same inputs produce the same heatmap patterns every time (for demo consistency). The rules per data type are:
Heatmap Metrics Simulation: Each of the six heatmap metrics is generated to mimic plausible warehouse patterns:
Volume (Movement Volume): Simulated with a log-normal distribution favoring certain hot spots. For example, front bins in Aisle A1 might consistently show higher throughput. This creates a realistic skew where some areas have much higher volume.
Frequency (Activity Frequency): Simulated via a Poisson distribution, with the event rate λ proportional to the volume at each location. Thus, locations with high volume also see more frequent picks/puts. This produces a pattern where high-volume areas stand out in both volume and frequency heatmaps, reinforcing realism.
Occupancy: Each bin’s occupancy (percent full) is randomized in a moderate range (e.g. 60–95% filled) with a slight bias to high occupancy overall (since warehouses are typically fairly full). This can be treated as current utilization percentage. The occupancy heatmap uses a gradient (e.g. low occupancy in cooler color, high in warmer color) to highlight underutilized vs. overutilized areas.
Misplacement: A small percentage of bins are flagged as having misplacements. For the demo, 1–2% of bins (randomly chosen each day) are marked “misplaced.” This could simulate inventory found in the wrong location. In the heatmap, these could be shown as distinct colored highlights or icons since it’s a binary flag rather than a continuous scale (e.g. any misplaced bin flashes or is outlined). The random selection is seeded so the same bins will consistently show as misplacements during a demo session.
Expiry (Near-Expiry Inventory): For each bin, if its occupancy is high (>80% filled) and a random check passes a threshold (say 10% chance), that bin is marked as containing near-expiry stock. This simulates that some fraction of heavily occupied bins have goods nearing expiration. These bins could be highlighted in an amber color on the expiry layer (to warn the user). The condition is recalculated periodically (e.g. daily) in the simulation. No actual dates are tracked in the demo; just a boolean flag per bin to indicate near-expiry status.
Exceptions: This layer flags “exceptional” events or problem spots. In the simulation, 0 to 3 random cells per hour are toggled to an “exception” state. An exception could mean a manual override, a cycle count discrepancy, or any anomaly. Visually, an exception might be represented with a red border or icon on that bin/area to draw attention. Since these come and go, the simulation will randomly activate a few at a time (and deactivate older ones) to mimic a dynamic environment. This yields a sparse but changing pattern of red-highlighted cells, indicating where issues are most frequent.
Resource Movement Simulation: The movement of forklifts (or other resource icons) is pre-scripted to appear purposeful:
Starting Positions: Three forklift icons spawn at a defined start point (e.g. near A1-B01-L1, the corner of aisle A1 at ground level).
Path Pattern: Each forklift follows a looping L-shaped path through the warehouse aisles. For example, a forklift might travel down Aisle 1, turn and come back up Aisle 2, covering a loop, then repeat or move to the next aisle in the next cycle. They avoid teleporting – movements are continuous along aisles with 90° turns at aisle ends (creating an L or U shape path). When reaching an end, they may reverse direction and retrace the route, or move to another aisle, simulating patrol routes.
Loaded State Toggle: To simulate pickups and drop-offs, each forklift toggles its loaded status every other segment of its route. For example, it starts empty, then after reaching a certain point (or after a timed interval), it switches to loaded (as if it picked something up), travels loaded (green path), then switches to empty after a drop-off (red path), and so on. Over a 5-minute window, one should see a mix of green and red segments in its path. Loaded state might also reflect in the icon (e.g. icon color or an icon variant could change if loaded, though that’s a nice-to-have detail).
Speed and Update Frequency: The forklifts’ movement speed is calibrated so that with updates every 1 second, they move a short distance per tick (ensuring smooth animation). The total cycle time for a loop might be on the order of a couple of minutes. All movement is confined within the aisle layout – they won’t go through walls or outside the defined grid.
These simulation rules ensure the demo data remains consistent and believable. The patterns (heatmaps and movement paths) will look deterministic on each demo run, which is useful for a rehearsed presentation, but still mimic the kind of variability and hotspots a real warehouse might exhibit.
UX/UI Design and Behavior
Even though this is a mock prototype, the user interface and experience should be polished and representative of a real application. Below are the key UI components and design considerations:
Overall Layout: The main screen consists of the warehouse map canvas as the central focus, overlaid with interactive elements (heatmaps, icons, etc.). A top or side toolbar provides controls such as layer toggles, the time-range slider, search bar, and export button. A legend is displayed to interpret the heatmap colors. On larger screens, the legend and controls can be shown with labels; on smaller screens, the toolbar may collapse to icon-only buttons for space. The design uses a responsive approach – for screen width ≥ 1280px, all UI elements (legend, toolbar, etc.) are fully visible, whereas for ≤ 768px some controls might collapse or hide (since this is primarily a dashboard for desktop, mobile view is not a primary concern but basic responsiveness is considered).
Heatmap Layers & Legend: Each of the six metric layers has an associated color scheme. The UI provides an intuitive way to select or toggle these overlays (e.g., a row of toggle buttons or a dropdown). Only one heatmap metric is actively colorized at a time (to avoid confusion), but users can toggle others off/on for comparison if needed. The legend is a small gradient bar that shows the color scale from minimum to maximum value for the currently active heatmap. It is labeled with the metric name and unit (if applicable) and may show numeric min/max values. For example, if “Volume” is selected, the legend might show a gradient from green (low moves) to red (high moves) with min=0 and max=100 moves/day (dummy values). A tooltip or label on the legend indicates “Volume (transactions/day)” for clarity. Similarly, Occupancy might show 0% to 100%, etc. Design note: we will use Tailwind CSS default color palette (e.g., amber-400 for warnings like expiry, red-500 for critical highlights, green-500 for positive or loaded indicators, etc.) to ensure a clean and consistent look without custom CSS. These colors are chosen to be color-blind friendly and easily distinguishable. For binary metrics (Misplacements, Exceptions), the legend might simply note the highlight color meaning (e.g., red outline = exception present).
Warehouse Map Canvas: The warehouse grid is drawn on an HTML5 Canvas element (using React-Konva, which provides a React binding for the Konva canvas library). This enables high-performance rendering of many objects (720+ bins, icons, etc.) with interactivity. The canvas is organized into multiple layers internally: one layer for the base grid (aisles and bins), one for each heatmap overlay, and one for dynamic entities (resources, highlights). Using separate layers ensures that toggling visibility and updating one layer (e.g., the heatmap) doesn’t require re-drawing others, improving performance and modularity. The canvas supports interactive features: users can zoom (with mouse wheel or pinch gesture) and pan (by dragging). We ensure that zooming/panning does not blur the canvas (Konva handles high-DPI rendering) and that text or icons scale appropriately. The background of the canvas could be a simple light grid or plain color to keep focus on data.
Resource Icons (Forklifts): Forklifts are represented by either a stylized icon or simple shape (e.g., a colored circle or forklift SVG). They are drawn on the canvas above the heatmap layer. Each icon might have a unique identifier shown on it or on hover (e.g., “FLT-01”). The icon’s color could remain constant or reflect state (for simplicity in MVP, we keep one icon style; in future, maybe green vs red if loaded, but since we already color paths, the icon itself can stay one color). The icons update position smoothly (thanks to Konva’s animation or manual tweening between the last and new position every second). This creates the impression of real RTLS-driven movement. Icons have tooltip info on hover or click – e.g., hovering could show “Forklift FLT-01\nCurrent Task: Loading pallets\nSpeed: 1.2 m/s” (if we choose to include such details for demo effect, though that data is mock). Clicking an icon not only triggers the path trace (FR-D04) but also opens a Trace Panel on the UI.
Trace Panel (Resource Details Drawer): When a resource is selected (clicked), a side panel slides in (likely from the right side of the app) to display details about that resource’s recent activity. This panel might include: total distance traveled in the last 5 min, percentage of time loaded vs empty, number of misplacement events handled (if any) or other stats. For example: “Forklift FLT-01 – Last 5 min: Distance traveled: 250m; Loaded 60% of time; 2 bins scanned.” This textual info complements the visual path on the map. The panel can be closed by the user (e.g., an X button) or by clicking the icon again. This panel helps demonstrate the kind of analytics the full product could provide (even though here it’s based on mock data calculations).
Time-Range Slider: The time-range slider is a horizontal control, likely placed at the bottom of the map or in a toolbar section. It might be visually represented with a handle the user can drag from “15m” on one end to “24h” on the other. As the user drags it, a small tooltip or label shows the selected range (e.g., “6 hours”). We debounce the input so the heatmap doesn’t update every millisecond of dragging – instead, once the user stops moving the slider, the heatmap data refreshes. The slider allows stakeholders to see how historical vs. real-time data might be viewed. In the demo, since data is synthetic, moving the slider will just change the random seed or distribution for heatmap generation to simulate a different time scope. For example, a shorter range might show a sparser heatmap (if only 15 minutes of data, maybe fewer events), whereas 24h might show the full pattern. This interaction should be smooth, and the UI should perhaps display the exact chosen window (like a label “Showing last 6 hours”).
Layer Toggle (“Eye” Icons): Each overlay (Volume, Frequency, Occupancy, Misplacement, Expiry, Exceptions, and the Resources layer) is listed in a legend or toolbar with a corresponding visibility toggle icon (often depicted as an eye or checkbox). By default, most layers are visible, except perhaps Exceptions or others if they clutter. Users can click the eye icon to hide a particular layer; for instance, to concentrate on one metric at a time. The UI will update the map immediately: hiding a heatmap layer removes its colored cells, hiding the resource layer removes forklift icons and traces, etc. The URL hash (e.g., #layers=volume+resources+exceptions) updates to encode which layers are on. If the user copies the URL or revisits it, the app reads that and restores the same configuration (this is an implementation detail handled via routing or state management). The design ensures the toggles are clearly visible and indicate state (e.g., highlighted when on, greyed out when off). This feature demonstrates modularity of layers and how the real app could allow customized views.
SKU Search Bar: The SKU search is a text input (with a search icon) typically located in the top toolbar. It allows dynamic searching: as the user types, it could highlight matches on the fly or after pressing Enter. In the MVP, for simplicity, search occurs on Enter or button click. The matching logic will look up the SKU in a mock inventory dataset (which maps SKUs to a list of cell IDs where they are stored). When matches are found, the corresponding bin cells on the map are visually highlighted. The highlight effect may involve a pulsing border around those bins or a temporary glow to catch the eye. Additionally, the camera could pan/zoom to ensure all found locations are in view (if they are spread out). If multiple SKUs match a partial query, an auto-complete dropdown might be shown (if time permits to implement) – otherwise, the first exact match is used. The UI should also provide a clear way to cancel the search (an “X” in the input to clear, or instruct ESC key usage). Once cleared, the map returns to normal. This feature emphasizes inventory lookup capabilities: in a real system, one could quickly find where a product is stored. For the demo, it’s a purely visual effect with no real backend query.
Export to PNG (UI control): The export feature is accessed via a small icon (for instance, a camera or download symbol) in the toolbar. When hovered, a tooltip might say “Download screenshot” or “Export view”. On click, the app will use the canvas and overlay data to generate an image. Under the hood, we use a library to traverse the DOM/canvas and produce a PNG data blob. The user sees a file download initiated in their browser. There’s minimal UI feedback needed (maybe a brief spinner or just the browser’s download prompt). This capability is useful for stakeholders as it hints that they could capture reports or evidence from the system – for now, only an image is supported (in later versions, PDF or CSV exports of raw data could be added, but those are out of scope in this front-end demo). The design of the image will include the visible legend so that the image is self-explanatory when shown outside the app context.
Visual Design & Styling: The overall look should be modern and clean, using Tailwind CSS for utility-first styling. We will leverage standard Tailwind color classes (like bg-gray-800 for toolbar, text-white for icons on dark background, etc.). The heatmap colors (red, green, amber, etc.) come from Tailwind’s palette (e.g., red-500, green-500, amber-400) for consistency. Typography is minimal – perhaps a sans-serif font for numbers and labels. Icons can come from a library like Heroicons (to ensure a consistent style). We avoid custom CSS as much as possible, relying on Tailwind for responsiveness (grid, flexbox) and spacing. Because this is a demo, we also ensure any demo-specific visuals (like perhaps a watermark “Demo” or the current time) are subtle. The UI polish is important: spacing should be even, elements aligned, no overlapping text, etc. Stakeholders should perceive this as nearly production-ready in look and feel. Tooltips and hover effects are included where they aid understanding (e.g., hover on a layer toggle might show “Show/Hide Volume Heatmap”). The interface will also be tested for various browser sizes to avoid layout breakage (though primarily aimed at Chrome on a desktop for the demo scenario).
In summary, the UI/UX is designed to convincingly simulate a fully functional warehouse visibility dashboard. It should be easy to use (even for a first-time viewer in a presentation), with intuitive controls and responsive feedback. All interactive elements (panning, clicking, toggling) should behave smoothly and without noticeable lag, reinforcing the impression of a polished product.
Technical Stack and Architecture (Demo)
This prototype is built with a modern web front-end stack to ensure fast development and a smooth demo experience:
React 18 + Vite: The application is written in React (functional components with Hooks) for a declarative UI structure. Vite is used as the build tool and development server, offering fast hot-module reloading and bundling, which is ideal for quick iteration (especially if hosting on a platform like Replit for the demo).
TypeScript: All code is written in TypeScript, providing static type checking for data models (e.g., defining types for Cell, Metric data, WebSocket messages). This helps catch errors early and ensures the dummy data structures (layout JSON, WebSocket payloads, etc.) conform to expected shapes.
Tailwind CSS 3: For styling, Tailwind CSS is employed, which allows rapid UI styling using utility classes. This avoids writing large custom CSS files. It ensures consistency in spacing, fonts, and colors. The design can easily adapt to dark mode or theme changes by adjusting Tailwind config if needed (not a current requirement, but a consideration).
react-konva (Konva.js): The core of the visualization uses the Konva framework via the react-konva bindings. Konva is an HTML5 Canvas library optimized for creating interactive 2D graphics. By using canvas, we can efficiently render hundreds of objects (the 720 bin cells, heatmap overlays, moving icons) with good performance. React-Konva allows treating canvas elements as part of React render, which simplifies state management for things like showing/hiding layers or updating positions
konvajs.org
. Konva also supports animations and drag-and-drop, which we leverage for smooth icon movements and panning.
Socket.io Client: To simulate live updates, we use Socket.io client library to connect to a mock WebSocket endpoint. In the demo setup, this could either connect to a small Node.js server emitting dummy data, or we might simulate the WebSocket within the browser (e.g., using a timer to call a handler every second). Either way, the Socket.io client gives us an easy interface to listen for “position updates” messages and then update the React state accordingly.
Faker.js (or similar): For generating random but realistic dummy data (especially for things like SKU lists, metrics values, etc.), we use a library like Faker.js. We will seed its random generator with a fixed value so that the random data is repeatable across sessions (important for demo consistency). Faker can produce lists of fake SKU codes, timestamps, etc., ensuring our dataset looks realistic (e.g., SKU “HX-2049” in aisle A3, etc.).
html-to-image: To implement the export functionality, we incorporate the html-to-image library (a well-maintained fork of dom-to-image). This library can take a DOM node (the map container) and convert it to an image (PNG) by internally using canvas and SVG. It handles the complexities of fonts and CSS. This is purely client-side. We chose this over alternatives like html2canvas for its reliability with SVG/Canvas and its support of modern features
npmjs.com
.
No Backend / Local Hosting: The MVP is entirely static and can be hosted on a static server or opened from a file. There is no API or database. All state is in-memory. For demonstration, we might deploy it on a static hosting service or run it locally in a browser. Because there’s no persistent data, a page refresh will reset the demo state (which is acceptable). The lack of backend simplifies setup and ensures there are no external dependencies or credentials needed for the demo.
Browser Support: Primarily, the target is a modern Chromium-based browser (Chrome/Edge) and possibly Firefox. We leverage ECMAScript 2020+ features via Vite’s build, and ensure polyfills if needed for any older browser features. Since this is controlled environment demo, cross-browser testing is minimal (focus on the environment that will be used for presentation).
All code in the project will be clearly commented, especially where fake data is used or where future integration points will come in. We mark such places with // TODO comments (for example, // TODO: Replace with real WebSocket endpoint or // TODO: Fetch real SKU locations from API). This is a note for developers who will later turn this prototype into a production feature, indicating how and where to plug in real logic.
Non-Functional Requirements
Even as a throwaway demo, the application should meet certain performance and quality benchmarks to ensure a smooth user experience:
Performance – Initial Load: The application should load and render the initial view within 3 seconds on a typical development laptop or hosted environment. The layout.json (which is the largest data file) is roughly 50 KB or less, and it should be fetched and processed quickly. We minimize bundle size by using Vite’s tree-shaking and not including heavy unused libraries. The first paint will show the base map and default heatmap layer promptly, so the audience isn’t left waiting.
Performance – Rendering & Interaction: The system should handle rendering all 1,440 pallet positions with heatmap overlays efficiently. Heatmap redraws (when switching layer or adjusting time range) should complete in under 0.5 seconds for the entire dataset (720 cells × 2 depths aggregated). We optimize by precomputing color values if possible and using Konva layers to update only changed elements. Panning and zooming the canvas should stay at 30+ FPS with no noticeable lag (which our use of canvas and layering facilitates). Animations (forklift movement) are lightweight (3 moving objects) and should not drop frames.
Resilience: As a front-end only app, there is little that can “go wrong” in terms of external failures, but we still handle edge cases. For example, if the WebSocket connection fails or closes, the app can log it and possibly retry or fall back to a timer update. If any of the data files (layout or initial metrics) fail to load, the UI should display an error message rather than crashing (e.g., “Failed to load layout data”). These contingencies ensure the demo doesn’t break mid-presentation.
Usability & Polish: The UI should be intuitive: new users (like stakeholders seeing the demo) can understand what they’re looking at without extensive explanation. We maintain consistent iconography and color coding (as noted, green vs red meaning loaded vs empty, etc., and use of standard icons for search, layer visibility, etc.). The design is uncluttered even though it presents a lot of data – thanks to toggles and good defaults. All interactive elements have appropriate cursor changes or hover highlights to indicate they are interactive. If time permits, adding tooltips or a brief on-screen guide (like a legend explaining each heatmap metric meaning) would further improve usability. The application should also respond well to different screen sizes (up to large monitors in a meeting room, or down to at least tablet size). It won’t be a native mobile app, but ensuring it’s not completely unusable on a smaller screen demonstrates attention to responsive design.
Maintainability (for future): The code structure is modular (separating components for Map, Legend, Controls, etc.). This separation will make it easier to replace the dummy data with real data sources later. We also ensure that the random generation has a single control (like a seed or a toggle for “demo mode”), so that transitioning to real mode can be done by disabling the dummy data generator.
In summary, while the focus is on delivering visible features, the non-functional aspects ensure the demo runs smoothly and gives a professional impression (no long waits, no crashes, fluid interaction).
Open Items and Questions
There are a few open questions that need to be resolved as we finalize the demo, especially to align with stakeholder expectations and design consistency:
Exact Color Scales for Heatmaps: What specific color gradients should each heatmap use? (Owner: Design, Needed by: Before final UI styling). We have a general plan to use Tailwind colors (e.g., green-yellow-red for intensities), but design input is needed to confirm the exact palette for each metric so that the visuals are consistent with any corporate branding or UX guidelines. For instance, should “Occupancy” use a blue scale instead? Should “Misplacements” use a particular icon? Finalizing this will ensure the legend and map look polished.
Resource Icon Graphics: What icons or shapes will represent moving resources (forklifts, pickers, etc.)? (Owner: Design, Needed by: Before development freeze). In the MVP we assume forklift icons for all moving entities. If there is an icon set available (for a person picker vs a forklift vs an AGV), we can include them, but if not, we’ll use one generic icon. Clarifying this will help avoid last-minute changes in the demo visuals. Ideally, design will provide a small SVG icon for a forklift to use.
Definition of “Exceptions” Metric: What qualifies as an exception and what text or tooltip should be shown for it? (Owner: Product, Needed by: Any time before demo). Since this is a demo, we created a generic notion of “exception = something went wrong here.” However, for realism, product management might define it more concretely (e.g., “exception means manual inventory override or system error occurred at this bin”). We also need a concise tooltip or legend description for the Exceptions layer to explain to viewers what a red-highlighted cell signifies. If this is not decided by demo time, we will keep it generic (“Exception: needs attention”) but it’s better to align it with actual intended use.
These open items should be addressed to avoid ambiguity during the stakeholder demo. The team will track them and incorporate the resolutions as soon as they are available.
Appendices
Appendix A – Sample Layout JSON Entry
The following is an example from the warehouse layout JSON file, illustrating how each cell is defined with coordinates and dimensions on the canvas grid:
json
Copy
Edit
{ 
  "cellId": "A2-B37-L2-D1", 
  "x": 250, 
  "y": 180, 
  "w": 20, 
  "h": 15 
}
In this example, the cell is in aisle A2, bin 37, level 2, depth 1 (front). The x, y coordinates position this bin’s rectangle in the canvas coordinate space, and w, h define the rectangle’s width and height (in pixels). All dimensions are calibrated so that adjacent bins align properly and the aspect ratio of aisle layouts is maintained. The origin (0,0) coordinate corresponds to a corner of the warehouse (e.g., bottom-left). These coordinates were pre-computed to simplify rendering (so the app doesn’t have to calculate positions on the fly). By iterating over this JSON, the app can draw the entire grid of 720 bin faces. Appendix B – WebSocket Payload Example
The demo uses a mock WebSocket feed to update resource locations. Here is an example JSON payload representing a single forklift status update:
json
Copy
Edit
{
  "id": "FLT-01",
  "x": 260,
  "y": 140,
  "loaded": true,
  "ts": 1720005600000
}
This payload indicates that the resource with ID “FLT-01” (ForkLift Truck 01) is now at coordinates (260, 140) on the map, is currently loaded (carrying a pallet), and the timestamp of this update is 1720005600000 (Unix timestamp in ms). In the demo, ts may simply be used for ordering and isn’t displayed. The front-end, upon receiving such an update, would locate the icon for “FLT-01” and animate it moving to (260, 140), and record that at that time the forklift was loaded (so the path segment to this point would be colored green). We simulate similar messages for each resource every second. The server side of this WebSocket is a simple loop or script sending out new coordinates (which follow the predefined path for each forklift).
This Product Requirements Document outlines a self-contained demo of the Warehouse Visibility module. By focusing on front-end functionality with simulated data, it provides a risk-free environment to validate the user experience and gather feedback. The demo will look and feel like a live system – with dynamic heatmaps and moving forklifts – giving stakeholders a compelling preview of the value the full product can deliver in terms of visibility and insights in warehouse operations.